{
  parserClass="DafnyLanguage.Parser.DafnyParser"
  parserUtilClass="DafnyLanguage.Parser.DafnyParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Dafny"
  psiImplClassSuffix="Impl"
  psiPackage="DafnyLanguage.psi"
  psiImplPackage="DafnyLanguage.psi.impl"

  elementTypeHolderClass="DafnyLanguage.psi.impl.DafnyTypeImpl"
  elementTypeClass="DafnyLanguage.psi.DafnyElementType"
  tokenTypeClass="DafnyLanguage.psi.DafnyTokenType"

  tokens = [

      bool = "regexp:bool"
      char = "regexp:char"
      int = "regexp:int"
      nattoken = "regexp:nat"
      real = "regexp:real"
      ORDINAL = "regexp:ORDINAL"
      object = "regexp:object"
      object_q = "regexp:object?"
      string = "regexp:string"
      set = "regexp:set"
      iset = "regexp:iset"
      multiset = "regexp:multiset"
      seq = "regexp:seq"
      map = "regexp:map"
      imap = "regexp:imap"
      colon = "regexp::"
      comma = "regexp:,"
      verticalbar = "regexp:\|"
      doublecolon = "regexp:::"
      gets = "regexp::="
      boredSmiley = "regexp::\|"
      bullet = "regexp:\u2022"
      twoDots = "regexp:\.\."
      dot = "regexp:\."
      backtick = "regexp:`"
      semi = "regexp:;"
      darrow = "regexp:=>"
      assume = "regexp:assume"
      calc = "regexp:calc"
      case = "regexp:case"
      then = "regexp:then"
      else = "regexp:else"
      as = "regexp:as"
      by = "regexp:by"
      in = "regexp:in"
      decreases = "regexp:decreases"
      invariant = "regexp:invariant"
      function = "regexp:function"
      predicate = "regexp:predicate"
      inductive = "regexp:inductive"
      twostate = "regexp:twostate"
      copredicate = "regexp:copredicate"
      lemma = "regexp:lemma"
      static = "regexp:static"
      protected = "regexp:protected"
      import = "regexp:import"
      export = "regexp:export"
      classToken = "regexp:class"
      trait = "regexp:trait"
      datatype = "regexp:datatype"
      codatatype = "regexp:codatatype"
      var = "regexp:var"
      const = "regexp:const"
      newtype = "regexp:newtype"
      type = "regexp:type"
      iterator = "regexp:iterator"
      method = "regexp:method"
      colemma = "regexp:colemma"
      constructor = "regexp:constructor"
      modifies = "regexp:modifies"
      reads = "regexp:reads"
      requires = "regexp:requires"
      ensures = "regexp:ensures"
      ghost = "regexp:ghost"
      witness = "regexp:witness"
      //new---
      include = "regexp:include"
      abstract = "regexp:abstract"
      module = "regexp:module"
      refines = "regexp:refines"
      provides = "regexp:provides"
      reveals = "regexp:reveals"
      extends = "regexp:extends"
      yields = "regexp:yields"
      returns = "regexp:returns"
      new = "regexp:new"
      comethod = "regexp:comethod"
      free = "regexp:free"
      label = "regexp:label"
      break = "regexp:break"
      if = "regexp:if"
      while = "regexp:while"
      match = "regexp:match"
      assert = "regexp:assert"
      print = "regexp:print"
      foralltoken = "regexp:forall"
      parallel = "regexp:parallel"
      modify = "regexp:modify"
      false = "regexp:false"
      true = "regexp:true"
      null = "regexp:null"
      this = "regexp:this"
      fresh = "regexp:fresh"
      allocated = "regexp:allocated"
      unchanged = "regexp:unchanged"
      old = "regexp:old"
      existstoken = "regexp:exists"
      opened = "regexp:opened"
      ghost = "regexp:ghost"
      yield = "regexp:yield"
      where = "regexp:where"
      return = "regexp:return"

      plus = "regexp:\+"
      minus = "regexp:\-"
      assign = "regexp:="
      boolAnd = "regexp:&&"
      boolOr = "regexp:\|\|"
      //----

      lbrace = "regexp:\{"
      rbrace = "regexp:\}"
      lbracket = "regexp:\["
      rbracket = "regexp:\]"
      openparen = "regexp:\("
      closeparen = "regexp:\)"
      eq = "regexp:=="
      neq = "regexp:\!="
      neqAlt = "regexp:\u2260"
      star = "regexp:\*"
      ellipsis = "regexp:\.\.\."
      reveal = "regexp:reveal"
      openAngleBracket = "regexp:<"
      closeAngleBracket = "regexp:>"

      charToken = "regexp:([']([^(\\)(\\\\)\r\n]|\\'|\\\"|\\\\|\\0|\\n|\\r|\\t|\\u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])')"
      stringToken = "regexp:([\"]([^\"\\\\\r\n]|\\'|\\\"|\\\\|\\0|\\n|\\r|\\t|\\u[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f])*)\"|@\"([^\"]|\"\")*\""

      notIn = "regexp:\!in"
      digits = "regexp:[0-9](_)?([0-9])*"
      hexdigits = "regexp:0x([0-9A-Fa-f])(_)?([0-9A-Fa-f])*"
      decimaldigits = "regexp:[0-9][_]?([0-9])*.([0-9])[_]?([0-9])*"
      arrayToken = "regexp:array([1-9])(([0-9])*)?"
      arrayToken_q = "regexp:array([1-9])(([0-9])*)?[?]"
      bvToken = "regexp:bv(0|([1-9])([0-9])* )"

      identdef="regexp:(([A-Zb-z?_])([A-ZZa-z_?0-9'`])*|a(([A-Za-z_?0-9])([A-Za-z_?0-9'])*)?|ar(([A-Za-qs-z_?0-9])([A-Za-z_?0-9'])*)?|arr(([A-Zb-z_?0-9])([A-Za-z_?0-9])*)?|arra(([A-Za-xz_?0-9])([A-Za-yz_?0-9])*)?|array([A-Za-z_?0])([A-Za-z_?0-9])*|array?([A-Za-z_?0-9])([A-Za-z_?0-9])*|array([1-9])([0-9])*([A-Za-z_])([A-Za-z_?0-9])*|array([1-9])([0-9])*?([A-Za-z_?0-9])([A-Za-z_?0-9])*|b(([A-Za-uwxyz_?0-9])([A-Za-z_?0-9])*)?|bv(([A-Za-z_?])([A-Za-z_?0-9])*)?|bv0([A-Za-z_?0-9])([A-Za-z_?0-9])*|bv([1-9])([A-Za-z_?0-9])*([A-Za-z_?])([A-Za-z_?0-9])*|'([A-Za-z_?0-9])?|'[A-Za-z_?0-9][A-Za-z_?0-9]|'[A-Za-z_?0-9][A-Za-z'_?0-9][A-Za-z_?0-9]([A-Za-z_?0-9])*)"

      comment = "regexp:\/\/.*|[/][*][^*]*[*]+([^*/][^*]*[*]+)*[/]"
      WHITE_SPACE = 'regexp:\s+'
  ]

}

//This empty Rule is needed for generating DafnyTypeImpl
Dafny ::=
